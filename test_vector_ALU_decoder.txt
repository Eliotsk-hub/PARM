# Unitary testing: test vectors for 32-bit ALU
# Ports:
# Entrées (32 bits, 32 bits, 5 bits, 1 bit, 4 bits) : A, B, Shift, CarryIn, Codop
# Sorties (32 bits, 4 bits) : S, Flags (NZCV)
# Utilisez le préfixe 0x pour les données 32 bits (A, B, S) en hexadécimal. Les valeurs 32 bits non utilisées sont 0x00000000.
# Flags (NZCV) : N=bit 3 (Négatif), Z=bit 2 (Zéro), C=bit 1 (Retenue), V=bit 0 (Débordement Signé).
# Ordre des ports: A[32] B[32] Shift[5] CarryIn[1] Codop[4] S[32] Flags[4]

A[32] B[32] Shift[5] CarryIn[1] Codop[4] S[32] Flags[4]

# Entrées: 32 bits | 32 bits | 5 bits | 1 bit | 4 bits
# Sorties: 32 bits | 4 bits

# ====================================================================
# 0000: AND (A and B)
# ====================================================================
0x0000000F 0x00000003 00000 0 0000 0x00000003 0000
0x0000000F 0x00000000 00000 0 0000 0x00000000 0100
0xFFFFFFFF 0x80000000 00000 0 0000 0x80000000 1000

# ====================================================================
# 0001: EOR (A xor B)
# ====================================================================
0x0000000A 0x00000005 00000 0 0001 0x0000000F 0000
0xFFFFFFFF 0xFFFFFFFF 00000 0 0001 0x00000000 0100
0x80000000 0x00000001 00000 0 0001 0x80000001 1000

# ====================================================================
# 0010: LSL (B << Shift)
# ====================================================================
0x00000000 0x00000001 00001 0 0010 0x00000002 0000
0x00000000 0x80000000 00001 0 0010 0x00000000 0110
0x00000000 0x00000001 11111 0 0010 0x80000000 1000

# ====================================================================
# 0011: LSR (B >> Shift)
# ====================================================================
0x00000000 0x00000002 00001 0 0011 0x00000001 0000
0x00000000 0x00000001 00001 0 0011 0x00000000 0110
0x00000000 0x80000000 00001 0 0011 0x40000000 0000

# ====================================================================
# 0100: ASR (B >> Shift Arith)
# ====================================================================
0x00000000 0x80000000 00001 0 0100 0xC0000000 1000
0x00000000 0x00000001 11111 0 0100 0x00000000 0100
0x00000000 0xFFFFFFFF 00011 0 0100 0xFFFFFFFF 1010

# ====================================================================
# 0101: ADC (A+B+CarryIn)
# ====================================================================
0x00000001 0x00000001 00000 0 0101 0x00000002 0000
0xFFFFFFFF 0x00000001 00000 0 0101 0x00000000 0110
0x7FFFFFFF 0x00000001 00000 0 0101 0x80000000 1001
0xFFFFFFFF 0x00000001 00000 1 0101 0x00000001 0010

# ====================================================================
# 0110: SBC (B-A-!CarryIn) 
# ====================================================================
0x00000001 0x00000002 00000 1 0110 0x00000001 0010
0x00000002 0x00000001 00000 1 0110 0xFFFFFFFF 1000
0x80000000 0x00000000 00000 1 0110 0x80000000 1001
0x00000001 0x00000000 00000 0 0110 0xFFFFFFFE 1000

# ====================================================================
# 0111: ROR (B >> Shift Rot) 
# ====================================================================
0x00000000 0x80000001 00001 0 0111 0xC0000000 1010
0x00000000 0x00000001 00001 0 0111 0x80000000 1010
0x00000000 0x00000000 00101 0 0111 0x00000000 0100

# ====================================================================
# 1000: TST (A and B, résultat perdu)
# ====================================================================
0x00000001 0x00000000 00000 0 1000 0x00000000 0100
0x80000000 0x80000000 00000 0 1000 0x80000000 1000

# ====================================================================
# 1001: RSB (-A, from 0) 
# ====================================================================
0x00000001 0x00000000 00000 0 1001 0xFFFFFFFF 1000
0x80000000 0x00000000 00000 0 1001 0x80000000 1001
0x00000000 0x00000000 00000 0 1001 0x00000000 0100

# ====================================================================
# 1010: CMP (B-A, résultat perdu)
# ====================================================================
0x00000001 0x00000002 00000 0 1010 0x00000001 0010
0x00000002 0x00000001 00000 0 1010 0xFFFFFFFF 1000
0xFFFFFFFF 0x7FFFFFFF 00000 0 1010 0x80000000 1001

# ====================================================================
# 1011: CMN (A+B, résultat perdu)
# ====================================================================
0x00000001 0x00000001 00000 0 1011 0x00000002 0000
0xFFFFFFFF 0x00000001 00000 0 1011 0x00000000 0110
0x7FFFFFFF 0x00000001 00000 0 1011 0x80000000 1001

# ====================================================================
# 1100: ORR (A or B)
# ====================================================================
0x0000000F 0x00000003 00000 0 1100 0x0000000F 0000
0x00000000 0x00000000 00000 0 1100 0x00000000 0100
0xFFFFFFFF 0x00000000 00000 0 1100 0xFFFFFFFF 1000

# ====================================================================
# 1101: MUL (A * B)
# ====================================================================
0x00000002 0x00000003 00000 0 1101 0x00000006 0000
0xFFFFFFFF 0x00000001 00000 0 1101 0xFFFFFFFF 1000
0x00000032 0x00000000 00000 0 1101 0x00000000 0100
0xFFFFFFFF 0xFFFFFFFF 00000 0 1101 0x00000001 0000

# ====================================================================
# 1110: BIC (B AND NOT A) 
# ====================================================================
0x00000000 0x0000000F 00000 0 1110 0x0000000F 0000
0x0000000F 0x0000000F 00000 0 1110 0x00000000 0100
0x00000000 0x80000000 00000 0 1110 0x80000000 1000

# ====================================================================
# 1111: MVN (NOT A) 
# ====================================================================
0x00000000 0x12345678 00000 0 1111 0xFFFFFFFF 1000
0xFFFFFFFF 0x12345678 00000 0 1111 0x00000000 0100
0x5555AAAA 0x00000000 00000 0 1111 0xAAAA5555 1000